package klox.tools

import java.io.File
import java.nio.charset.StandardCharsets.UTF_8
import kotlin.system.exitProcess

fun defineAst(outputDir: String, baseName: String, types: List<String>) = File("$outputDir/$baseName.kt").writeText(
    """
/**
 * This class is generated by GenerateAst.kt. Do not modify!!!
 */
package klox.ast

import klox.interpreter.Token

sealed class $baseName() {
    abstract fun <R> accept(visitor: Visitor<R>): R
${defineVisitor(baseName, types)}

${defineTypes(baseName, types)}
}
""".trimIndent(), UTF_8
)

fun defineTypes(baseName: String, types: List<String>) = types.map {
    val (className, fields) = it.split(":")
    defineType(baseName, className.trim(), fields)
}.joinToString("\n\n")

fun defineType(baseName: String, className: String, fieldString: String): String {
    val fields = fieldString.split(",").map { it.trim() }.filterNot { it.isEmpty() }
    val params = fields.map { it.split(" ") }.joinToString(", ") { (type, name) -> "val $name: $type" }
    return """
    data class $className($params) : $baseName() { 
        override fun <R> accept(visitor: Visitor<R>) = visitor.visit(this) 
    }""".trimMargin()
}

fun defineVisitor(baseName: String, types: List<String>) = """
    interface Visitor<R> {
${
    types.joinToString("\n") {
        val className = it.split(":")[0].trim()
        "        fun visit(${baseName.lowercase()}: $className): R"
    }
  }
    }"""

fun main(args: Array<String>) {
    if (args.size != 1) {
        System.err.println("Usage: generate_ast <output directory>")
        exitProcess(64)
    }

    val outputDir = args[0]

    defineAst(
        outputDir, "Expr", listOf(
            "Assign  : Token name, Expr value",
            "Binary  : Expr left, Token operator, Expr right",
            "Call    : Expr callee, Token paren, List<Expr> arguments",
            "Get     : Expr obj, Token name",
            "Grouping: Expr expression",
            "Literal : Any? value",
            "Logical : Expr left, Token operator, Expr right",
            "Set     : Expr obj, Token name, Expr value",
            "Variable: Token name",
            "Unary   : Token operator, Expr right"
        )
    )

    defineAst(
        outputDir, "Stmt", listOf(
            "Block       : List<Stmt> statements",
            "Class       : Token name, List<Stmt.Function> methods",
            "Expression  : Expr expression",
            "Function    : Token name, List<Token> params, List<Stmt> body",
            "If          : Expr condition, Stmt thenBranch, Stmt? elseBranch",
            "Print       : Expr expression",
            "Return      : Token keyword, Expr? value",
            "While       : Expr condition, Stmt body",
            "Var         : Token name, Expr? initializer"
        )
    )
}
